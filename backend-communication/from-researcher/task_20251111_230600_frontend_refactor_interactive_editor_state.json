{
  "id": "task_20251111_230600_frontend_refactor_interactive_editor_state",
  "from": "researcher",
  "to": "frontend",
  "timestamp": "2025-11-11T23:06:00.000Z",
  "type": "task",
  "priority": "high",
  "status": "pending",
  "subject": "IMPLEMENT: Refactor InteractiveEditor State - Dynamic Text Elements Array",
  "body": {
    "content": "## Context\n\nCurrently, InteractiveEditor has separate state for each text field:\n```typescript\nconst [headline, setHeadline] = useState('...');\nconst [subheadline, setSubheadline] = useState('...');\nconst [cta, setCta] = useState('...');\nconst [textPositions, setTextPositions] = useState<TextPositions>(...);\n```\n\nWe need to refactor to a **unified array-based state** that supports unlimited text elements:\n```typescript\nconst [textElements, setTextElements] = useState<TextElement[]>(...);\n```\n\n**This task:** Refactor state management and integrate DraggableTextBox component.\n\n**Depends on:**\n- task_20251111_230400 (asset type flow)\n- task_20251111_230500 (DraggableTextBox component)\n\n---\n\n## Task Breakdown\n\n### **Subtask 1: Replace State with Text Elements Array**\n\n**File:** `src/components/InteractiveEditor.tsx`\n\n**Remove old state:**\n```typescript\n// ❌ REMOVE:\nconst [headline, setHeadline] = useState('Your Headline Here');\nconst [subheadline, setSubheadline] = useState('');\nconst [cta, setCta] = useState('Scan to Learn More');\nconst [textPositions, setTextPositions] = useState<TextPositions>(defaultTextPositions);\n```\n\n**Add new state:**\n```typescript\nimport type { TextElement, QRCodePosition } from '@/types/asset';\nimport { v4 as uuidv4 } from 'uuid';  // For generating tempIds\n\n// ✅ NEW STATE:\nconst [textElements, setTextElements] = useState<TextElement[]>([]);\nconst [qrPosition, setQRPosition] = useState<QRCodePosition>({\n  x: 875,\n  y: 1500,\n  size: 850\n});\nconst [selectedElementId, setSelectedElementId] = useState<string | null>(null);\nconst [draggingElementId, setDraggingElementId] = useState<string | null>(null);\nconst [resizingElementId, setResizingElementId] = useState<string | null>(null);\n```\n\n---\n\n### **Subtask 2: Initialize Default Text Elements**\n\n**Create default elements from compositionMap:**\n\n```typescript\nuseEffect(() => {\n  if (!compositionMap || textElements.length > 0) return;\n  \n  // Initialize with default text elements\n  const defaultElements: TextElement[] = [\n    {\n      tempId: uuidv4(),\n      type: 'headline',\n      label: 'Headline',\n      content: 'Your Headline Here',\n      position: {\n        x: compositionMap?.headline?.x || 170,\n        y: compositionMap?.headline?.y || 726,\n        width: compositionMap?.headline?.width || 2210,\n        height: 'auto'\n      },\n      styling: {\n        fontSize: compositionMap?.headline?.fontSize || 153,\n        fontWeight: 'bold',\n        textAlign: 'center',\n        color: textColors.headline || '#FFFFFF',\n        italic: false,\n        underline: false,\n        letterSpacing: 0,\n        lineSpacing: 10\n      },\n      constraints: {\n        maxLength: 100,\n        required: true\n      },\n      displayOrder: 0\n    },\n    {\n      tempId: uuidv4(),\n      type: 'subheadline',\n      label: 'Subheadline',\n      content: '',\n      position: {\n        x: compositionMap?.subheadline?.x || 170,\n        y: compositionMap?.subheadline?.y || 1188,\n        width: compositionMap?.subheadline?.width || 2210,\n        height: 'auto'\n      },\n      styling: {\n        fontSize: compositionMap?.subheadline?.fontSize || 93,\n        fontWeight: 'normal',\n        textAlign: 'center',\n        color: textColors.subheadline || '#FFFFFF',\n        italic: false,\n        underline: false,\n        letterSpacing: 0,\n        lineSpacing: 10\n      },\n      constraints: {\n        maxLength: 150,\n        required: false\n      },\n      displayOrder: 1\n    },\n    {\n      tempId: uuidv4(),\n      type: 'cta',\n      label: 'Call to Action',\n      content: 'Scan to Learn More',\n      position: {\n        x: compositionMap?.cta?.x || 170,\n        y: compositionMap?.cta?.y || 2383,\n        width: compositionMap?.cta?.width || 2210,\n        height: 'auto'\n      },\n      styling: {\n        fontSize: compositionMap?.cta?.fontSize || 93,\n        fontWeight: 'bold',\n        textAlign: 'center',\n        color: textColors.cta || '#FFFFFF',\n        italic: false,\n        underline: false,\n        letterSpacing: 0,\n        lineSpacing: 10\n      },\n      constraints: {\n        maxLength: 50,\n        required: true\n      },\n      displayOrder: 2\n    }\n  ];\n  \n  setTextElements(defaultElements);\n}, [compositionMap, textColors]);\n```\n\n---\n\n### **Subtask 3: Create Text Element Update Functions**\n\n```typescript\n/**\n * Update a text element by ID\n */\nfunction updateTextElement(id: string, updates: Partial<TextElement>) {\n  setTextElements(prev => prev.map(el => \n    el.tempId === id ? { ...el, ...updates } : el\n  ));\n}\n\n/**\n * Update text element position\n */\nfunction updateTextElementPosition(id: string, position: Partial<TextElement['position']>) {\n  setTextElements(prev => prev.map(el =>\n    el.tempId === id \n      ? { ...el, position: { ...el.position, ...position } }\n      : el\n  ));\n}\n\n/**\n * Update text element styling\n */\nfunction updateTextElementStyling(id: string, styling: Partial<TextElement['styling']>) {\n  setTextElements(prev => prev.map(el =>\n    el.tempId === id\n      ? { ...el, styling: { ...el.styling, ...styling } }\n      : el\n  ));\n}\n\n/**\n * Update text element content\n */\nfunction updateTextElementContent(id: string, content: string) {\n  setTextElements(prev => prev.map(el =>\n    el.tempId === id ? { ...el, content } : el\n  ));\n}\n\n/**\n * Move element forward in display order (+1)\n */\nfunction moveElementForward(id: string) {\n  setTextElements(prev => {\n    const index = prev.findIndex(el => el.tempId === id);\n    if (index === -1 || index === prev.length - 1) return prev;  // Already at front\n    \n    const newElements = [...prev];\n    const currentOrder = newElements[index].displayOrder;\n    const nextElement = newElements.find(el => el.displayOrder === currentOrder + 1);\n    \n    if (nextElement) {\n      newElements[index].displayOrder = currentOrder + 1;\n      nextElement.displayOrder = currentOrder;\n    }\n    \n    return newElements.sort((a, b) => a.displayOrder - b.displayOrder);\n  });\n}\n\n/**\n * Move element backward in display order (-1)\n */\nfunction moveElementBackward(id: string) {\n  setTextElements(prev => {\n    const index = prev.findIndex(el => el.tempId === id);\n    if (index === -1 || prev[index].displayOrder === 0) return prev;  // Already at back\n    \n    const newElements = [...prev];\n    const currentOrder = newElements[index].displayOrder;\n    const prevElement = newElements.find(el => el.displayOrder === currentOrder - 1);\n    \n    if (prevElement) {\n      newElements[index].displayOrder = currentOrder - 1;\n      prevElement.displayOrder = currentOrder;\n    }\n    \n    return newElements.sort((a, b) => a.displayOrder - b.displayOrder);\n  });\n}\n\n/**\n * Move element to front (highest displayOrder)\n */\nfunction moveElementToFront(id: string) {\n  setTextElements(prev => {\n    const maxOrder = Math.max(...prev.map(el => el.displayOrder));\n    return prev.map(el =>\n      el.tempId === id ? { ...el, displayOrder: maxOrder + 1 } : el\n    ).sort((a, b) => a.displayOrder - b.displayOrder)\n    .map((el, idx) => ({ ...el, displayOrder: idx }));  // Normalize\n  });\n}\n\n/**\n * Move element to back (displayOrder = 0)\n */\nfunction moveElementToBack(id: string) {\n  setTextElements(prev => {\n    return prev.map(el =>\n      el.tempId === id ? { ...el, displayOrder: -1 } : el\n    ).sort((a, b) => a.displayOrder - b.displayOrder)\n    .map((el, idx) => ({ ...el, displayOrder: idx }));  // Normalize\n  });\n}\n```\n\n---\n\n### **Subtask 4: Replace Rendering with DraggableTextBox Loop**\n\n**Remove old hardcoded blocks (~300 lines):**\n```typescript\n// ❌ REMOVE ALL OF THIS:\n{/* Draggable Headline */}\n{headline && (\n  <>\n    <div ref={headlineRef} ... />\n    <Moveable ref={headlineMoveableRef} ... />\n  </>\n)}\n\n{/* Draggable Subheadline */}\n{subheadline && (\n  <>\n    <div ref={subheadlineRef} ... />\n    <Moveable ref={subheadlineMoveableRef} ... />\n  </>\n)}\n\n{/* Draggable CTA */}\n{cta && (\n  <>\n    <div ref={ctaRef} ... />\n    <Moveable ref={ctaMoveableRef} ... />\n  </>\n)}\n```\n\n**Replace with dynamic loop:**\n```typescript\nimport { DraggableTextBox } from './DraggableTextBox';\nimport { detectOverlappingElements } from '@/utils/geometryHelpers';\n\n// Detect overlaps\nconst overlappingIds = detectOverlappingElements(textElements, qrPosition);\n\n// Render all text elements\n{textElements\n  .filter(el => el.content.trim() !== '')  // Only show non-empty\n  .map((element) => (\n    <DraggableTextBox\n      key={element.tempId}\n      textElement={element}\n      onUpdate={updateTextElement}\n      isDragging={draggingElementId === element.tempId}\n      isResizing={resizingElementId === element.tempId}\n      onDragStart={() => {\n        setDraggingElementId(element.tempId);\n        setSelectedElementId(element.tempId);\n      }}\n      onDragEnd={(left, top) => {\n        setDraggingElementId(null);\n        const clamped = clampPosition(\n          left,\n          top,\n          element.position.width,\n          element.position.height\n        );\n        updateTextElementPosition(element.tempId, {\n          x: clamped.x,\n          y: clamped.y\n        });\n      }}\n      onResizeStart={() => {\n        setResizingElementId(element.tempId);\n        setSelectedElementId(element.tempId);\n      }}\n      onResizeEnd={(width, height, left, top) => {\n        setResizingElementId(null);\n        const clamped = clampPosition(left, top, width, height);\n        updateTextElementPosition(element.tempId, {\n          x: clamped.x,\n          y: clamped.y,\n          width: Math.round(width),\n          height: height === 'auto' ? 'auto' : Math.round(height)\n        });\n      }}\n      bounds={{ left: 0, top: 0, right: ASSET_DIMENSIONS.width, bottom: ASSET_DIMENSIONS.height }}\n      verticalGuidelines={VERTICAL_GUIDELINES}\n      horizontalGuidelines={HORIZONTAL_GUIDELINES}\n      hasOverlap={overlappingIds.has(element.tempId)}\n    />\n  ))}\n```\n\n---\n\n### **Subtask 5: Update Generate Handler**\n\n**Replace old generate logic:**\n```typescript\n// ❌ OLD:\nconst handleGenerate = () => {\n  onGenerate({ headline, subheadline, cta, textPositions, textColors });\n};\n```\n\n**New generate logic:**\n```typescript\n// ✅ NEW:\nconst handleGenerate = () => {\n  // Filter out empty text elements\n  const nonEmptyElements = textElements.filter(el => el.content.trim() !== '');\n  \n  // Validate required elements\n  const hasHeadline = nonEmptyElements.some(el => el.type === 'headline' && el.content.trim() !== '');\n  if (!hasHeadline) {\n    toast({\n      title: 'Headline Required',\n      description: 'Please enter a headline before generating.',\n      variant: 'destructive'\n    });\n    return;\n  }\n  \n  // Send to parent\n  onGenerate({\n    text_elements: nonEmptyElements,\n    qr_position: qrPosition\n  });\n};\n```\n\n---\n\n### **Subtask 6: Update clampPosition for Asset Type**\n\n**Use assetSpec dimensions instead of hardcoded:**\n\n```typescript\nfunction clampPosition(\n  x: number,\n  y: number,\n  width: number,\n  height: number | 'auto'\n) {\n  const roundedWidth = Math.round(width);\n  const roundedHeight = height === 'auto' ? 100 : Math.round(height);\n  \n  // ⭐ Use assetSpec dimensions (not hardcoded 2550x3300)\n  const maxX = assetSpec.width - roundedWidth;\n  const maxY = assetSpec.height - roundedHeight;\n  \n  return {\n    x: Math.max(0, Math.min(Math.round(x), maxX)),\n    y: Math.max(0, Math.min(Math.round(y), maxY)),\n    width: Math.max(assetSpec.min_text_width, Math.min(roundedWidth, assetSpec.width)),\n    height: height === 'auto' ? 'auto' : Math.max(assetSpec.min_text_height, roundedHeight)\n  };\n}\n```\n\n---\n\n## Success Criteria\n\n- [ ] Old state variables removed (headline, subheadline, cta, textPositions)\n- [ ] textElements array state added\n- [ ] Default text elements initialized from compositionMap\n- [ ] Update functions created (updateTextElement, updatePosition, updateStyling, etc.)\n- [ ] Layer ordering functions created (moveForward, moveBackward, toFront, toBack)\n- [ ] Old hardcoded JSX blocks removed (~300 lines)\n- [ ] DraggableTextBox loop renders all elements\n- [ ] Overlap detection integrated\n- [ ] Generate handler validates and sends text_elements array\n- [ ] clampPosition uses assetSpec dimensions\n- [ ] No TypeScript errors\n- [ ] Text elements can be dragged and resized\n\n---\n\n## Testing Checklist\n\n```bash\n# Test dynamic text elements\n1. Open InteractiveEditor\n2. Verify 3 default text elements appear (headline, subheadline, CTA)\n3. Drag headline - verify it moves and clamps to canvas\n4. Resize headline - verify width updates\n5. Edit headline content - verify it updates\n6. Drag elements to overlap - verify warning badges appear\n7. Test layer ordering (should be added in Task 4)\n8. Click Generate - verify text_elements array sent to parent\n```\n\n---\n\n## Notes for Frontend\n\n**Can use subagents for:**\n- Removing old state and JSX (1 subagent - cleanup)\n- Creating update functions (1 subagent)\n- Integrating DraggableTextBox loop (1 subagent)\n- Updating generate handler (1 subagent)\n\n**Depends on:**\n- Task 1 (assetSpec available)\n- Task 2 (DraggableTextBox component)\n\n**Enables:**\n- Task 4 (Text styling controls) - needs this state structure\n- Task 5 (API integration) - needs text_elements array format\n\n---\n\n## Code Reduction\n\n**Before:** ~1008 lines (InteractiveEditor.tsx)\n**After:** ~700 lines (estimate)\n**Removed:** ~300 lines of duplicate code\n\n---\n\n## Estimated Time\n\n**Total: 25 minutes**\n- Remove old state/JSX: 5 minutes\n- Add new state: 5 minutes\n- Create update functions: 10 minutes\n- Integrate DraggableTextBox loop: 5 minutes",
    "attachments": [],
    "verification_checklist": [
      "Old state removed",
      "textElements array state added",
      "Default elements initialized",
      "Update functions created",
      "Layer ordering functions created",
      "Old JSX removed",
      "DraggableTextBox loop renders elements",
      "Overlap detection works",
      "Generate handler sends text_elements array",
      "clampPosition uses assetSpec",
      "No TypeScript errors",
      "Text elements draggable and resizable"
    ]
  },
  "execution": {
    "estimated_time": "25 minutes",
    "timeout": 35,
    "complexity": "high"
  },
  "metadata": {
    "related_files": [
      "src/components/InteractiveEditor.tsx"
    ],
    "api_endpoints": [],
    "requires_testing": true,
    "depends_on": [
      "task_20251111_230400_frontend_asset_type_wizard_flow",
      "task_20251111_230500_frontend_create_draggable_text_box_component"
    ]
  }
}
