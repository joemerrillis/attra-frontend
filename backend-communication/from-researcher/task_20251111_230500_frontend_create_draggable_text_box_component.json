{
  "id": "task_20251111_230500_frontend_create_draggable_text_box_component",
  "from": "researcher",
  "to": "frontend",
  "timestamp": "2025-11-11T23:05:00.000Z",
  "type": "task",
  "priority": "high",
  "status": "pending",
  "subject": "IMPLEMENT: Create DraggableTextBox Component (Unified, Reusable)",
  "body": {
    "content": "## Context\n\nCurrently, InteractiveEditor has ~300 lines of duplicated code for headline, subheadline, and CTA. We need to create ONE reusable component that handles all text elements.\n\n**Current duplication:**\n- Lines 402-506: Draggable Headline\n- Lines 508-612: Draggable Subheadline\n- Lines 700-804: Draggable CTA\n\n**All three blocks are identical except for the field name.**\n\n**This task:** Extract into a single `DraggableTextBox` component that can be used for any text element.\n\n**Depends on:** task_20251111_230400 (needs assetSpec for bounds)\n\n---\n\n## Task Breakdown\n\n### **Subtask 1: Define TextElement Interface**\n\n**File:** `src/types/asset.ts`\n\n**Add new interfaces:**\n\n```typescript\nexport interface TextElement {\n  tempId: string;  // Client-side ID (not persisted to database)\n  type: 'headline' | 'subheadline' | 'body' | 'quote' | 'cta' | 'custom';\n  label: string;  // Display name: \"Headline\", \"Customer Quote\", etc.\n  content: string;\n  position: {\n    x: number;\n    y: number;\n    width: number;\n    height: number | 'auto';\n  };\n  styling: {\n    fontSize: number;\n    fontWeight: 'normal' | 'bold';\n    textAlign: 'left' | 'center' | 'right' | 'justify';\n    color: string;  // Hex: '#FFFFFF'\n    italic: boolean;\n    underline: boolean;\n    letterSpacing: number;\n    lineSpacing: number;\n  };\n  constraints?: {\n    maxLength: number;\n    required: boolean;\n  };\n  displayOrder: number;  // For layering\n}\n\nexport interface QRCodePosition {\n  x: number;\n  y: number;\n  size: number;\n}\n```\n\n---\n\n### **Subtask 2: Create DraggableTextBox Component**\n\n**File:** `src/components/DraggableTextBox.tsx` (new file)\n\n```typescript\nimport { useRef } from 'react';\nimport Moveable from 'react-moveable';\nimport { flushSync } from 'react-dom';\nimport type { TextElement } from '@/types/asset';\n\ninterface DraggableTextBoxProps {\n  textElement: TextElement;\n  onUpdate: (id: string, updates: Partial<TextElement>) => void;\n  isDragging: boolean;\n  isResizing: boolean;\n  onDragStart: () => void;\n  onDragEnd: (left: number, top: number) => void;\n  onResizeStart: () => void;\n  onResizeEnd: (width: number, height: number, left: number, top: number) => void;\n  bounds: { left: number; top: number; right: number; bottom: number };\n  verticalGuidelines: number[];\n  horizontalGuidelines: number[];\n}\n\nexport function DraggableTextBox({\n  textElement,\n  onUpdate,\n  isDragging,\n  isResizing,\n  onDragStart,\n  onDragEnd,\n  onResizeStart,\n  onResizeEnd,\n  bounds,\n  verticalGuidelines,\n  horizontalGuidelines\n}: DraggableTextBoxProps) {\n  const ref = useRef<HTMLDivElement>(null);\n  const moveableRef = useRef<Moveable>(null);\n\n  return (\n    <>\n      <div\n        ref={ref}\n        className={`draggable-text ${\n          isDragging ? 'dragging' : ''\n        } ${\n          isResizing ? 'resizing' : ''\n        }`}\n        style={{\n          position: 'absolute',\n          left: `${textElement.position.x}px`,\n          top: `${textElement.position.y}px`,\n          width: `${textElement.position.width}px`,\n          height: textElement.position.height === 'auto' \n            ? 'auto' \n            : `${textElement.position.height}px`,\n          fontSize: `${textElement.styling.fontSize}px`,\n          fontWeight: textElement.styling.fontWeight,\n          fontStyle: textElement.styling.italic ? 'italic' : 'normal',\n          textDecoration: textElement.styling.underline ? 'underline' : 'none',\n          color: textElement.styling.color,\n          fontFamily: 'Arial, sans-serif',\n          textAlign: textElement.styling.textAlign,\n          letterSpacing: `${textElement.styling.letterSpacing}px`,\n          lineHeight: `${textElement.styling.fontSize + textElement.styling.lineSpacing}px`,\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: textElement.styling.textAlign === 'left' \n            ? 'flex-start' \n            : textElement.styling.textAlign === 'right' \n            ? 'flex-end' \n            : 'center',\n          cursor: isDragging ? 'grabbing' : 'grab',\n          userSelect: 'none',\n          padding: '8px',\n          wordWrap: 'break-word',\n          whiteSpace: 'pre-line',\n          overflow: 'hidden',\n          textShadow: textElement.styling.color === '#FFFFFF'\n            ? '2px 2px 4px rgba(0,0,0,0.8)'\n            : 'none',\n        }}\n      >\n        {textElement.content}\n      </div>\n      \n      <Moveable\n        ref={moveableRef}\n        target={ref}\n        draggable={true}\n        resizable={true}\n        snappable={true}\n        snapThreshold={21}\n        verticalGuidelines={verticalGuidelines}\n        horizontalGuidelines={horizontalGuidelines}\n        isDisplaySnapDigit={true}\n        bounds={bounds}\n        renderDirections={['w', 'e', 'n', 's']}\n        flushSync={flushSync}\n        onDragStart={onDragStart}\n        onDrag={(e) => {\n          if (e.target instanceof HTMLElement) {\n            e.target.style.left = `${e.left}px`;\n            e.target.style.top = `${e.top}px`;\n          }\n        }}\n        onDragEnd={(e) => {\n          onDragEnd(e.lastEvent!.left, e.lastEvent!.top);\n        }}\n        onResizeStart={onResizeStart}\n        onResize={(e) => {\n          if (e.target instanceof HTMLElement) {\n            e.target.style.width = `${e.width}px`;\n            e.target.style.height = `${e.height}px`;\n            e.target.style.left = `${e.drag.left}px`;\n            e.target.style.top = `${e.drag.top}px`;\n          }\n        }}\n        onResizeEnd={(e) => {\n          onResizeEnd(\n            e.lastEvent!.width,\n            e.lastEvent!.height,\n            e.lastEvent!.drag.left,\n            e.lastEvent!.drag.top\n          );\n        }}\n      />\n    </>\n  );\n}\n```\n\n---\n\n### **Subtask 3: Create Layer Ordering Controls**\n\n**File:** `src/components/LayerOrderingControls.tsx` (new file)\n\n```typescript\nimport { ArrowUp, ArrowDown, MoveUp, MoveDown } from 'lucide-react';\nimport { Button } from '@/components/ui/button';\n\ninterface LayerOrderingControlsProps {\n  currentOrder: number;\n  totalLayers: number;\n  onMoveForward: () => void;    // +1\n  onMoveBackward: () => void;   // -1\n  onMoveToFront: () => void;    // Move to top\n  onMoveToBack: () => void;     // Move to bottom\n}\n\nexport function LayerOrderingControls({\n  currentOrder,\n  totalLayers,\n  onMoveForward,\n  onMoveBackward,\n  onMoveToFront,\n  onMoveToBack\n}: LayerOrderingControlsProps) {\n  const isTop = currentOrder === totalLayers - 1;\n  const isBottom = currentOrder === 0;\n\n  return (\n    <div className=\"flex items-center gap-2 bg-white rounded-lg shadow-md p-2 border\">\n      <span className=\"text-xs text-gray-600 px-2\">\n        Layer {currentOrder + 1} of {totalLayers}\n      </span>\n      \n      <div className=\"flex gap-1\">\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMoveToBack}\n          disabled={isBottom}\n          title=\"Send to Back\"\n        >\n          <MoveDown className=\"w-4 h-4\" />\n        </Button>\n        \n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMoveBackward}\n          disabled={isBottom}\n          title=\"Move Backward\"\n        >\n          <ArrowDown className=\"w-4 h-4\" />\n        </Button>\n        \n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMoveForward}\n          disabled={isTop}\n          title=\"Move Forward\"\n        >\n          <ArrowUp className=\"w-4 h-4\" />\n        </Button>\n        \n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          onClick={onMoveToFront}\n          disabled={isTop}\n          title=\"Bring to Front\"\n        >\n          <MoveUp className=\"w-4 h-4\" />\n        </Button>\n      </div>\n    </div>\n  );\n}\n```\n\n---\n\n### **Subtask 4: Create Overlap Detection Utility**\n\n**File:** `src/utils/geometryHelpers.ts` (new file)\n\n```typescript\nimport type { TextElement, QRCodePosition } from '@/types/asset';\n\n/**\n * Check if two rectangles overlap\n */\nexport function rectanglesOverlap(\n  rect1: { x: number; y: number; width: number; height: number | 'auto' },\n  rect2: { x: number; y: number; width: number; height: number | 'auto' }\n): boolean {\n  // Treat 'auto' height as 100px for overlap detection\n  const h1 = rect1.height === 'auto' ? 100 : rect1.height;\n  const h2 = rect2.height === 'auto' ? 100 : rect2.height;\n  \n  return !(\n    rect1.x + rect1.width < rect2.x ||\n    rect2.x + rect2.width < rect1.x ||\n    rect1.y + h1 < rect2.y ||\n    rect2.y + h2 < rect1.y\n  );\n}\n\n/**\n * Detect which text elements are overlapping\n * @returns Set of tempIds for overlapping elements\n */\nexport function detectOverlappingElements(\n  textElements: TextElement[],\n  qrPosition: QRCodePosition\n): Set<string> {\n  const overlapping = new Set<string>();\n  \n  // Check text-to-text overlaps\n  for (let i = 0; i < textElements.length; i++) {\n    for (let j = i + 1; j < textElements.length; j++) {\n      if (rectanglesOverlap(textElements[i].position, textElements[j].position)) {\n        overlapping.add(textElements[i].tempId);\n        overlapping.add(textElements[j].tempId);\n      }\n    }\n    \n    // Check text-to-QR overlap\n    const qrRect = { x: qrPosition.x, y: qrPosition.y, width: qrPosition.size, height: qrPosition.size };\n    if (rectanglesOverlap(textElements[i].position, qrRect)) {\n      overlapping.add(textElements[i].tempId);\n    }\n  }\n  \n  return overlapping;\n}\n```\n\n---\n\n### **Subtask 5: Add Overlap Warning Badge**\n\n**File:** Update `DraggableTextBox.tsx`\n\n**Add prop:**\n```typescript\ninterface DraggableTextBoxProps {\n  // ... existing props\n  hasOverlap?: boolean;  // ⭐ NEW\n}\n```\n\n**Add warning badge in render:**\n```typescript\n<div ref={ref} className=\"...\" style={{...}}>\n  {hasOverlap && (\n    <div className=\"absolute top-0 right-0 bg-yellow-500 text-white text-xs px-2 py-1 rounded\">\n      ⚠️ Overlaps\n    </div>\n  )}\n  {textElement.content}\n</div>\n```\n\n---\n\n## Success Criteria\n\n- [ ] TextElement interface defined in types\n- [ ] DraggableTextBox component created and working\n- [ ] Component supports all styling options (alignment, italic, underline, spacing)\n- [ ] Layer ordering controls component created\n- [ ] Overlap detection utility created\n- [ ] Overlap warning badge shows when elements overlap\n- [ ] Component is fully reusable (no hardcoded field names)\n- [ ] No TypeScript errors\n- [ ] Component can be rendered multiple times for different text elements\n\n---\n\n## Testing Checklist\n\n```typescript\n// Test component in isolation\nimport { DraggableTextBox } from '@/components/DraggableTextBox';\n\nfunction TestPage() {\n  const [element, setElement] = useState<TextElement>({\n    tempId: 'test-1',\n    type: 'headline',\n    label: 'Test Headline',\n    content: 'Hello World',\n    position: { x: 100, y: 100, width: 500, height: 'auto' },\n    styling: {\n      fontSize: 100,\n      fontWeight: 'bold',\n      textAlign: 'center',\n      color: '#FFFFFF',\n      italic: false,\n      underline: false,\n      letterSpacing: 0,\n      lineSpacing: 10\n    },\n    displayOrder: 0\n  });\n  \n  return (\n    <div style={{ position: 'relative', width: 600, height: 900, background: '#ccc' }}>\n      <DraggableTextBox\n        textElement={element}\n        onUpdate={(id, updates) => {\n          console.log('Update:', id, updates);\n        }}\n        isDragging={false}\n        isResizing={false}\n        onDragStart={() => console.log('Drag start')}\n        onDragEnd={(left, top) => console.log('Drag end:', left, top)}\n        onResizeStart={() => console.log('Resize start')}\n        onResizeEnd={(w, h, l, t) => console.log('Resize end:', w, h, l, t)}\n        bounds={{ left: 0, top: 0, right: 600, bottom: 900 }}\n        verticalGuidelines={[150, 300, 450]}\n        horizontalGuidelines={[225, 450, 675]}\n      />\n    </div>\n  );\n}\n```\n\n---\n\n## Notes for Frontend\n\n**Can use subagents for:**\n- Creating DraggableTextBox component (1 subagent)\n- Creating LayerOrderingControls (1 subagent)\n- Creating overlap detection utilities (1 subagent)\n\n**This component is used by:**\n- Task 3 (State management refactor) - InteractiveEditor will render DraggableTextBox in a loop\n\n**Safe to work on in parallel with:**\n- Task 3 (State management)\n- Both can be integrated after completion\n\n---\n\n## Estimated Time\n\n**Total: 20 minutes**\n- DraggableTextBox component: 10 minutes\n- Layer ordering controls: 5 minutes\n- Overlap detection: 5 minutes",
    "attachments": [],
    "verification_checklist": [
      "TextElement interface defined",
      "DraggableTextBox component created",
      "All styling options work (alignment, italic, underline, spacing)",
      "LayerOrderingControls component created",
      "Overlap detection utility created",
      "Overlap warning shows correctly",
      "Component is reusable",
      "No TypeScript errors",
      "Component renders multiple instances correctly"
    ]
  },
  "execution": {
    "estimated_time": "20 minutes",
    "timeout": 30,
    "complexity": "medium"
  },
  "metadata": {
    "related_files": [
      "src/types/asset.ts",
      "src/components/DraggableTextBox.tsx",
      "src/components/LayerOrderingControls.tsx",
      "src/utils/geometryHelpers.ts"
    ],
    "api_endpoints": [],
    "requires_testing": true,
    "depends_on": ["task_20251111_230400_frontend_asset_type_wizard_flow"]
  }
}
